/** 
 * Array Functions
 */

let iveMembersArray = ['안유진', '가을', '레이', '장원영', '리즈', '이서', '민주', '혜원'];


console.log(iveMembersArray);

console.log(iveMembersArray.push('새로운멤버'));  // push 메서드는 배열의 끝에 하나 이상의 요소를 추가하고, 새로운 배열 길이를 반환합니다.
// 출력: 9

//pop()
console.log(iveMembersArray.pop()); // pop 메서드는 배열의 마지막 요소를 제거하고, 제거된 요소를 반환합니다.
// 출력: 새로운멤버
// 자료구조에서 확인할수있다.

console.log(iveMembersArray.shift()); // shift 메서드는 배열의 첫 번째 요소를 제거하고, 제거된 요소를 반환합니다.
// 출력: 안유진

console.log(iveMembersArray.unshift('안유진')); // unshift 메서드는 배열의 시작 부분에 하나 이상의 요소를 추가하고, 새로운 배열 길이를 반환합니다.
// 출력: 8


console.log(iveMembersArray.splice(2, 1, '유진')); // splice 메서드는 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다.
// 여기서는 인덱스 2에서 1개의 요소를 제거하고, '유진'을 그 위치에 추가합니다.
// 출력: ['레이'] - 제거된 요소를 반환합니다.


// immutable한 코딩 스타일이 선호되기 때문에 splice보다는 slice를 사용하자.

console.log(iveMembersArray.concat('새로운멤버2')); // concat 메서드는 두 개 이상의 배열을 병합하여 새로운 배열을 생성합니다. 여기서는 '새로운멤버2'를 기존 배열에 추가한 새로운 배열을 반환합니다.
// 출력: ['가을', '유진', '장원영', '리즈', '이서', '민주', '혜원', '새로운멤버2']
// 아예 다른 메모리 공간이라고 생각하면 됨. 받아주는 변수 없으면 안됨.

console.log(iveMembersArray.slice(1, 4)); // slice 메서드는 배열의 일부분을 추출하여 새로운 배열을 생성합니다. 여기서는 인덱스 1부터 4까지(4는 포함되지 않음)의 요소를 추출합니다.
// 출력: ['가을', '유진', '장원영']

console.log(iveMembersArray.indexOf('리즈')); // indexOf 메서드는 배열에서 특정 요소를 찾고, 그 요소의 첫 번째 인덱스를 반환합니다. 요소가 없으면 -1을 반환합니다.
// 출력: 4

// spread operator
let newIveMembersArray = [...iveMembersArray, '새로운멤버3'];
console.log(newIveMembersArray); // 출력: ['가을', '유진', '장원영', '리즈', '이서', '민주', '혜원', '새로운멤버3']
// 기존 배열을 복사하고, 그 뒤에 '새로운멤버3'을 추가한 새로운 배열을 생성합니다.
// ... 을 안넣으면 중첩배열 이 된다.

// ...iveMembers -> 근데 이렇게 되면 배열이 풀려서 각각의 멤버들이 다 들어가게 된다. 허나 다른 메모리값을 가지게 되어 불리언 비교시
// false가 나오게 된다.

// 배열 함수들은 원본 배열을 변경하지 않는 것들이 많다. (immutable한 코딩 스타일이 선호되기 때문)
// 따라서, 새로운 배열을 반환하는 경우가 많으므로, 반환값을 받아주는 변수가 필요하다.

// 배열 함수들은 자주 쓰이니 꼭 익숙해지자!

//join()
console.log(iveMembersArray.join(', ')); // join 메서드는 배열의 모든 요소를 연결하여 하나의 문자열로 만듭니다. 여기서는 각 요소를 ', '로 구분합니다.

//sort()
let numbersArray = [5, 3, 8, 1, 2];
numbersArray.sort((a, b) => a - b); // sort 메서드는 배열의 요소를 정렬합니다. 여기서는 숫자를 오름차순으로 정렬합니다.
console.log(numbersArray); // 출력: [1, 2, 3, 5, 8]
console.log(numbersArray.reverse()); // reverse 메서드는 배열의 요소 순서를 반전시킵니다.
// 출력: [8, 5, 3, 2, 1]
/**
 * 참고
 * sort 메서드의 정렬법은 기본적으로 문자열 유니코드 코드 포인트 순서에 따라 정렬합니다.
 * 따라서, 숫자 배열을 정렬할 때는 비교 함수를 제공하여 원하는 정렬 방식을 정의하는 것이 중요합니다.
 * 로직은 자바스크립트 엔진마다 다를 수 있습니다.
 */

let numbers = [
    1,9,7,5,3
];

console.log(numbers);


//a, b를 비교했을 때
// 1) a를 b보다 나중에 정렬하려면 (뒤에두려면) 0 보다 큰 숫자를 반환
// 2) a를 b보다 먼저 정렬하려면 (앞에두려면) 0 보다 작은 숫자를 반환
// 3) a와 b의 순서를 변경하지 않으려면 0을 반환

numbers.sort((a,b) => a > b ? 1 : -1); // a가 b보다 크면 1을 반환해서 a를 b보다 나중에 정렬
// 해석
// a가 b보다 크면 1을 반환해서 a를 b보다 나중에 정렬
// a가 b보다 작으면 -1을 반환해서 a를 b보다 먼저 정렬
// 왜 1을 반환했는데 앞에 오는거지? -> sort메서드가 1을 반환하면 a를 b보다 나중에 정렬하라고 했으니까 b가 먼저 오게 되는거지.
// 왜 입력하는 파라미터가 a,b인거지? -> sort메서드가 배열의 요소들을 두 개씩 비교하면서 정렬을 하기 때문에 그런거지.
// 정해진 규칙이 있는건데 확인해볼 수 있는 방법이 있을까?
// MDN문서에서 Array.prototype.sort()를 확인해보면 정렬 기준에 대한 설명이 나와있다.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
// a와 b에 들어가는 값들의 순서는 sort메서드가 알아서 정하는거지 유저가 정하는건 아님.
// 이렇게됐을 때 빅오는 nlogn이 되려나? 
// sort 메서드는 일반적으로 퀵소트나 힙소트 같은 알고리즘을 사용하므로, 평균적으로 O(n log n)의 시간 복잡도를 가진다.
// 하지만, 최악의 경우에는 O(n^2)까지도 될 수 있다. (예: 이미 정렬된 배열을 역순으로 정렬할 때)
// 내림차순으로 정렬하고싶으면 앞으로 계속 바꿔야할껀가?
// 그냥 sort()와 무엇이 다를까
// sort()는 기본적으로 문자열 유니코드 코드 포인트 순서에 따라 정렬하기 때문에, 숫자 배열을 정렬할 때는 원하는 결과를 얻지 못할 수 있다.
// 예를 들어, [10, 2, 1]을 sort()로 정렬하면 ['1', '10', '2']가 되어 숫자 크기 순서대로 정렬되지 않는다.
// 따라서, 숫자 배열을 정렬할 때는 비교 함수를 제공하여 원하는 정렬 방식을 정의하는 것이 중요하다.

console.log(numbers); // 출력: [1, 3, 5, 7, 9]




/**
 * map
 * 배열의 각 요소에 대해 제공된 함수를 호출하고, 그 결과로 새로운 배열을 생성합니다.
 * 즉 immutable한 방식을 선호하는 코딩 스타일에서 자주 사용됩니다.
 */

console.log(iveMembersArray.map((x) => `${x}님`));
// map 메서드는 배열의 각 요소에 대해 제공된 함수를 호출하고, 그 결과로 새로운 배열을 생성합니다.
// 여기서는 각 멤버 이름 뒤에 '님'을 붙인 새로운 배열을 생성합니다.
// 출력: ['가을님', '유진님', '장원영님', '리즈님', '이서님', '민주님', '혜원님']

console.log(iveMembersArray.map((x)=> {
    if(x === '안유진') {
        return `아이브 : ${x}님`;
    } else {
        return x;
    }
}))


/**
 * filter
 * 배열의 각 요소에 대해 제공된 함수를 호출하고, 그 결과가 true인 요소들로 새로운 배열을 생성합니다.
 * map으로도 가능하지만 직관적인 방법은 filter임
 */


numbers = [1,2,3,4,5,6,7,8,9,10];

console.log(numbers.filter((x) => { return x % 2 === 0; }))


/**
 * find
 * 배열의 각 요소에 대해 제공된 함수를 호출하고, 그 결과가 true인 첫 번째 요소를 반환합니다.
 * 만약 조건을 만족하는 요소가 없다면 undefined를 반환합니다.
 */

console.log(numbers.find((x) => x > 5)); // 출력: 6 즉, 단일값반환


/**
 * findIndex()
 * 배열의 각 요소에 대해 제공된 함수를 호출하고, 그 결과가 true인 첫 번째 요소의 인덱스를 반환합니다.
 * 만약 조건을 만족하는 요소가 없다면 -1을 반환합니다.
 */

console.log(numbers.findIndex((x) => x > 5)); // 출력: 5 즉, 단일값반환 (인덱스값)

/**
 * reduce()
 * 배열의 각 요소에 대해 제공된 함수를 호출하고, 그 결과를 누적하여 단일 값을 반환합니다.
 * 여기서는 배열의 모든 요소를 더하는 예제를 보여줍니다.
 */
console.log(numbers.reduce((p, n) => p + n , 0)) // 초기값이 두번째 파라미터로 들어감.
// 출력: 55
// p는 누적값(이전 함수 호출의 반환값), n은 현재 요소입니다.
// 초기값을 0으로 설정했기 때문에, 첫 번째 호출에서 p는 0이고, n은 배열의 첫 번째 요소인 1이 됩니다.
// 이후 호출에서는 p가 이전 호출의 반환값이 되고, n이 다음 요소가 됩니다.
// 최종적으로 모든 요소를 더한 값이 반환됩니다.

/**순서
 * 1. 초기값 0이 p에 할당됨
 * 2. numbers 어레이의 첫번째 값인 1이 n에 할당됨
 * 3. p + n 이 실행되어 0 + 1 = 1 이 반환됨
 * 4. 3에서 반환된 값 (1)이 다음 호출에서 p에 할당됨
 * 5. numbers 어레이의 두번째 값인 (2)가 n에 할당됨
 * 6. p + n 이 실행되어 1 + 2 = 3 이 반환됨
 * 7. 6에서 반환된 값 (3)이 다음 호출에서 p에 할당됨
 * 8. numbers 어레이의 세번째 값인 (3)가 n에 할당됨
 ...
 이런식으로 마지막 요소까지 반복됨
 */

/**
 * 그러니까 reduce는 배열의 모든 요소를 하나의 값으로 축소하는데 좋음.
 * 모든값 더하기, 모든 값 빼기, 모든 값 곱하기, 모든값 평균내기 등등 다양하게 활용가능.
 * 그리고 리듀스는 초기값을 설정할 수 있어서, 빈 배열에 대해서도 안전하게 동작함.
 * 조건식의 결과를 가지고 계속 연산을 한다는 점에서 유용함. 모든 값을 하나의 상징으로 나타낼 수도 있고 임의의 자체 해쉬값을 만들 수도 있음.
 */